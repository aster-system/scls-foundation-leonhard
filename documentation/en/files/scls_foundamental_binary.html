<!DOCTYPE html>
<html lang="fr">
    <head>
        <link rel="stylesheet" href="../style.css">
        <meta charset="utf-8">
        <title>SCLS Foundamental "Leonhard" - Binary</title>
    </head>
    <body>
        <h1>SCLS Foundamental Binary</h1>
        <h2>Presentation</h2>
        <div>
            SCLS Foundamental Binary allows the user to do some simple, but secure binary manipulation.</br></br>
            WARNING : Using binary can cause troubles if you don't know what you do. Be very careful with that.
        </div>
        <h2>
            Content
        </h2>
        <div>
            SCLS Foundamental Binary has a lot of differents features, presented here.
            <h3>
                The "Binary" class
            </h3>
            <div>
                The main thing about this part of SCLS Foundamental is the "Binary" class. It represents a class allowing to do some binary manipulation very easily.</br>
                To be simple, it is a char array enhanced in all points.
                It can manipulate bytes, convert others types to bytes, extract bytes datas to other types datas, do binary file manipulation...
                It provides a protection against buffer overflow error (if you use it correctly) and against data loss.
                It is used in a lot of features in SCLS, and even in others Aster System codes.</br>
                Some types, like double, need a conversion to another type, with EXACTLY the same bit pattern, but without the same value according to their type.
                For double, it is converted to an int64_t to be stored, and reconverted to be used.
                <h4>
                    Methods
                </h4>
                <div>
                    The methods are documented in alphabetical order, which may not be their place in the code.</br>
                    Excepting the constructors, which is at the start, and the destructor, at the end.
                    <h5>
                        Binary()
                    </h5>
                    <div>
                        Most simple Binary constructor, which does not allocate datas in the memory.
                    </div>
                    <h5>
                        Binary(char* new_datas, unsigned int new_datas_size)
                    </h5>
                    <div>
                        Advanced Binary constructor, putting the datas of the object to "new_datas" and the size of the datas to "new_datas_size".
                    </div>
                    <h5>
                        Binary(const Binary& binary)
                    </h5>
                    <div>
                        Binary copy constructor, putting the datas of the object to copied "binary" datas, same for the size of the datas.
                    </div>
                    <h5>
                        void add_data(char data)
                    </h5>
                    <div>
                        Add "data" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_datas(char* datas_to_add, unsigned int datas_to_add_size)
                    </h5>
                    <div>
                        Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_datas(const char* datas_to_add, unsigned int datas_to_add_size)
                    </h5>
                    <div>
                        Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_double(double data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the double "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_float(float data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the float "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.</br>
                        WARNING : for now, this function only convert the float to a double and use "add_double". So, it can occurs to unexpected behaviors in some cases.
                    </div>
                    <h5>
                        void add_int(int data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_int64(int64_t data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the int64_t "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_short(short data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_string(std::string data)
                    </h5>
                    <div>
                        Add the std::string "data" at the end of the datas in the object, by default encoded in UTF-8 (if you well configured your encoder).
                    </div>
                    <h5>
                        void add_uint(unsigned int data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the unsigned int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_ushort(unsigned short data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the unsigned short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        char* datas() const
                    </h5>
                    <div>
                        Return the datas into the object.
                    </div>
                    <h5>
                        unsigned int datas_size() const
                    </h5>
                    <div>
                        Return the size of the datas into the object.
                    </div>
                    <h5>
                        char data_at(unsigned int position)
                    </h5>
                    <div>
                        Return the data at the position "position" in the datas.</br>
                        If the position is not in the datas field, the SCLS print function is used to tell it to the user, and the function return 0.</br>
                        It is HIGLY RECOMMENDED to use this function to access datas without the "extract" functions, because it can avoid buffer overflow.
                    </div>
                    <h5>
                        char extract_data(unsigned int offset = 0)
                    </h5>
                    <div>
                        Extract and return a byte, with a position offset of "offset".
                    </div>
                    <h5>
                        char* extract_datas(unsigned int extract_size, unsigned int offset = 0, bool inverse = false)
                    </h5>
                    <div>
                        Extract and return a "extract_size" sized amount of data, with a position offset of "offset", inversed or not depending to "inverse".
                    </div>
                    <h5>
                        double extract_double(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a double, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        float extract_float(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a float, with a position offset of "offset", in big_endian or not depending to "big_endian".</br>
                        WARNING : for now, this function only convert the float to a double and use "extract_double". So, it can occurs to unexpected behaviors in some cases.
                    </div>
                    <h5>
                        int extract_int(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an int, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int extract_int64(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an int64_t, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        short extract_short(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a short, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        std::string extract_string(unsigned int extract_size, unsigned int offset = 0)
                    </h5>
                    <div>
                        Extract and return a std::string of size "extract_size", with a position offset of "offset".
                    </div>
                    <h5>
                        unsigned int extract_uint(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an unsigned int, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned short extract_ushort(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an unsigned short, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void free_memory()
                    </h5>
                    <div>
                        Free the memory of the datas, and reset the datas.</br>
                        If the datas are a "0" pointer, then the memory is freed.
                    </div>
                    <h5>
                        bool load_from_file(std::string path)
                    </h5>
                    <div>
                        Load the datas of the object from a file at the path "path" and return file is all is good.</br>
                        If the path does not exist, the object is not loaded and "false" is returned.
                    </div>
                    <h5>
                        void save(std::string path)
                    </h5>
                    <div>
                        Save the datas of the object in a file at the path "path".
                    </div>
                    <h5>
                        ~Binary()
                    </h5>
                    <div>
                        Binary class destructor, calling the "free_memory" function.
                    </div>
                </div>
            </div>
            <h3>
                Binary manipulation
            </h3>
            <div>
                Even if the Binary class exists, there are some char array manipulation functions.
                They do the same things that in the Binary class, but in a less optimized way (even if they are used in the class).
                Excluding if you have no choice, it is recommended to use the Binary class instead of this functions.
                <h4>
                    Functions
                </h4>
                <div>
                    <h5>
                        short extract_2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract a short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned short extract_u2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an unsigned short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int extract_4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned int extract_u4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an unsigned int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int64_t extract_8bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an int64_t from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        double extract_double_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract a double from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_2bytes_to_char_array(short n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_2bytes_to_char_array(unsigned short n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the unsigned short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_4bytes_to_char_array(int n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_4bytes_to_char_array(unsigned int n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the unsigned int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_8bytes_to_char_array(int64_t n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the int64_t "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_8bytes_double_to_char_array(double n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the double "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                </div>
            </div>
            <h3>
                Binary file manipulation
            </h3>
            <div>
                Even if the Binary class exists, there are some binary file manipulation functions.
                They do the same things that in the Binary class, but in a less optimized way (even if they are used in the class).
                Excluding if you have no choice, it is recommended to use the Binary class instead of this functions.
                <h4>
                    Functions
                </h4>
                <div>
                    <h5>
                        void read_file_binary(std::string path, char* datas, unsigned int size, unsigned int start_pos = 0)
                    </h5>
                    <div>
                        Put "size" bytes of the file at the path "path" into the char array "datas", starting at the pos "start_pos" in the file.
                    </div>
                    <h5>
                        char* read_entire_file_binary(std::string path, unsigned int& total_size)
                    </h5>
                    <div>
                        Put the entire content of the file at the path "path" into the char array returned, and put into the referenced variable "total_size" the size of the datas.
                    </div>
                    <h5>
                        void write_in_file_binary(std::string path, char* to_write, unsigned int size, std::ios::openmode opening_mode = std::ios::out | std::ios::binary)
                    </h5>
                    <div>
                        Write "size" bytes of the char array "to_write", in the file at the path "path", opened with the mode defined by "opening_mode".
                    </div>
                </div>
            </div>
            <h3>
                Code specification
            </h3>
            <div>
                This file define the macro "SCLS_FOUNDATION_BINARY".
            </div>
        </div>
    </body>
</html>