<!DOCTYPE html>
<html lang="fr">
    <head>
        <link rel="stylesheet" href="../style.css">
        <meta charset="utf-8">
        <title>SCLS Foundamental "Leonhard" - Binary</title>
    </head>
    <body>
        <h1>SCLS Foundamental Binary</h1>
        <h2>Presentation</h2>
        <div>
            SCLS Foundamental Binary allows the user to do some simple, but secure binary manipulation.</br></br>
            WARNING : Using binary can cause troubles if you don't know what you do. Be very careful with that.
        </div>
        <h2>
            Content
        </h2>
        <div>
            SCLS Foundamental Binary has a lot of differents features, presented here.
            <h3>
                The "Bytes_Set" class
            </h3>
            <div>
                The main thing about this part of SCLS Foundamental is the "Bytes_Set" class. It represents a class allowing to do some binary manipulation very easily.</br>
                To be simple, it is a char array enhanced in all points.
                It can manipulate bytes, convert others types to bytes, extract bytes datas to other types datas, do binary file manipulation...
                It provides a protection against buffer overflow error (if you use it correctly) and against data loss.
                It is used in a lot of features in SCLS, and even in others Aster System codes.</br>
                Some types, like double, need a conversion to another type, with EXACTLY the same bit pattern, but without the same value according to their type.
                For double, it is converted to an int64_t to be stored, and reconverted to be used.
                <h4>
                    Methods
                </h4>
                <div>
                    The methods are documented in alphabetical order, which may not be their place in the code.</br>
                    Excepting the constructors, which is at the start, and the destructor, at the end.
                    <h5>
                        Bytes_Set()
                    </h5>
                    <div>
                        Most simple Bytes_Set constructor, which does not allocate datas in the memory.
                    </div>
                    <h5>
                        Bytes_Set(char* new_datas, unsigned int new_datas_size)
                    </h5>
                    <div>
                        Advanced Bytes_Set constructor, putting the datas of the object to "new_datas" and the size of the datas to "new_datas_size".
                    </div>
                    <h5>
                        Bytes_Set(const Bytes_Set& byte_set)
                    </h5>
                    <div>
                        Bytes_Set copy constructor, putting the datas of the object to copied "byte_set" datas, same for the size of the datas.
                    </div>
                    <h5>
                        void add_data(char data)
                    </h5>
                    <div>
                        Add "data" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_datas(char* datas_to_add, unsigned int datas_to_add_size)
                    </h5>
                    <div>
                        Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_datas(const char* datas_to_add, unsigned int datas_to_add_size)
                    </h5>
                    <div>
                        Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.
                    </div>
                    <h5>
                        void add_double(double data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the double "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_float(float data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the float "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.</br>
                        WARNING : for now, this function only convert the float to a double and use "add_double". So, it can occurs to unexpected behaviors in some cases.
                    </div>
                    <h5>
                        void add_int(int data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_int64(int64_t data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the int64_t "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_short(short data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_string(std::string data)
                    </h5>
                    <div>
                        Add the std::string "data" at the end of the datas in the object, by default encoded in UTF-8 (if you well configured your encoder).
                    </div>
                    <h5>
                        void add_uint(unsigned int data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the unsigned int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        void add_ushort(unsigned short data, bool big_endian = false)
                    </h5>
                    <div>
                        Add the unsigned short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.
                    </div>
                    <h5>
                        char* datas() const
                    </h5>
                    <div>
                        Return the datas into the object.
                    </div>
                    <h5>
                        unsigned int datas_size() const
                    </h5>
                    <div>
                        Return the size of the datas into the object.
                    </div>
                    <h5>
                        char data_at(unsigned int position)
                    </h5>
                    <div>
                        Return the data at the position "position" in the datas.</br>
                        If the position is not in the datas field, the SCLS print function is used to tell it to the user, and the function return 0.</br>
                        It is HIGLY RECOMMENDED to use this function to access datas without the "extract" functions, because it can avoid buffer overflow.
                    </div>
                    <h5>
                        char extract_data(unsigned int offset = 0)
                    </h5>
                    <div>
                        Extract and return a byte, with a position offset of "offset".
                    </div>
                    <h5>
                        char* extract_datas(unsigned int extract_size, unsigned int offset = 0, bool inverse = false)
                    </h5>
                    <div>
                        Extract and return a "extract_size" sized amount of data, with a position offset of "offset", inversed or not depending to "inverse".
                    </div>
                    <h5>
                        double extract_double(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a double, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        float extract_float(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a float, with a position offset of "offset", in big_endian or not depending to "big_endian".</br>
                        WARNING : for now, this function only convert the float to a double and use "extract_double". So, it can occurs to unexpected behaviors in some cases.
                    </div>
                    <h5>
                        int extract_int(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an int, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int extract_int64(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an int64_t, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        short extract_short(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return a short, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        std::string extract_string(unsigned int extract_size, unsigned int offset = 0)
                    </h5>
                    <div>
                        Extract and return a std::string of size "extract_size", with a position offset of "offset".
                    </div>
                    <h5>
                        unsigned int extract_uint(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an unsigned int, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned short extract_ushort(unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract and return an unsigned short, with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void free_memory()
                    </h5>
                    <div>
                        Free the memory of the datas, and reset the datas.</br>
                        If the datas are a "0" pointer, then the memory is freed.
                    </div>
                    <h5>
                        bool load_from_file(std::string path)
                    </h5>
                    <div>
                        Load the datas of the object from a file at the path "path" and return file is all is good.</br>
                        If the path does not exist, the object is not loaded and "false" is returned.
                    </div>
                    <h5>
                        void save(std::string path)
                    </h5>
                    <div>
                        Save the datas of the object in a file at the path "path".
                    </div>
                    <h5>
                        void set_data_at(unsigned int position, char new_data)
                    </h5>
                    <div>
                        Set the data at the position "position" at "new_data".
                    </div>
                    <h5>
                        ~Bytes_Set()
                    </h5>
                    <div>
                        Bytes_Set class destructor, calling the "free_memory" function.
                    </div>
                </div>
            </div>
            <h3>
                CRC manipulation
            </h3>
            <div>
                This file contains a way to handle simple CRC manipulation.
                CRC is an algorithm allowing to check datas, to know if their transmission was successfull or not.</br>
                The only sized algorithm handled is 32 bits for now. Each algorithm has a name, made to easily use them.</br>
                If you want more information about CRC, see <a href="https://github.com/gentooinit/crc/blob/master/crc.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>.
                <h4>
                    Built-in algorithms
                </h4>
                <div>
                    <h5>
                        PNG CRC algorithm
                    </h5>
                    <div>
                        The file has a built-in CRC, called "png", made to use the CRC algorithm of the PNG format.
                    </div>
                </div>
                <h4>
                    Functions
                </h4>
                <div>
                    <h5>
                        bool contains_crc_32b(std::string name)
                    </h5>
                    <div>
                        Returns if the CRC 32 bits algorithm "name" is loaded or not.
                    </div>
                    <h5>
                        unsigned int crc_32b(char* buf, int len, std::string crc_name)
                    </h5>
                    <div>
                        Return the CRC value of the char* "buf" of size "len", with the datas of the loaded CRC_32B_Datas named "name". 
                    </div>
                    <h5>
                        unsigned int crc_32b(unsigned char* buf, int len, std::string crc_name)
                    </h5>
                    <div>
                        Return the CRC value of the unsigned char* "buf" of size "len", with the datas of the loaded CRC_32B_Datas named "name". 
                    </div>
                    <h5>
                        CRC_32B_Datas* get_crc_32b_data(std::string name)
                    </h5>
                    <div>
                        Returns a pointer to the CRC_32B_Datas named "name".</br>
                        If is does not exists, it returns 0 or it creates it if the name is built-in.
                    </div>
                    <h5>
                        void make_crc_32b_table(std::string name, unsigned int polymonial, bool reflect_input, bool reflect_output, unsigned int starting_value, unsigned int xor_final)
                    </h5>
                    <div>
                        Create a CRC 32 bits algorithm with the passed values.</br>
                        Each values directly goes into the same named CRC_32B_Datas attribute.
                    </div>
                </div>
                <h4>
                    Hidden things
                </h4>
                <div>
                    <h5>
                        std::map&lt;std::string, CRC_32B_Datas&gt; _loaded_crc32_algorithms
                    </h5>
                    <div>
                        This variable stores the loaded CRC 32 bits algorithms.</br>
                        It's not recommended to use it directly. Use "get_crc_32b_data" instead.
                    </div>
                </div>
                <h4>
                    Macros
                </h4>
                <div>
                    <h5>
                        #define PNG_CRC_POLYMONIAL 0x04c11db7
                    </h5>
                    <div>
                        Polymonial of the PNG CRC algorithm.
                    </div>
                </div>
                <h4>
                    Struct CRC_32B_Datas
                </h4> 
                <div>
                    By default, all the values permit to load the CRC datas of the PNG CRC algorithm.
                    <h5>
                        unsigned int crc_values[256]
                    </h5>
                    <div>
                        All 256 CRC values possible for this algorithm.
                    </div>
                    <h5>
                        unsigned int polymonial
                    </h5>
                    <div>
                        Value of the polymonial of the CRC, by default to PNG_CRC_POLYMONIAL.
                    </div>
                    <h5>
                        bool reflect_input = true
                    </h5>
                    <div>
                        If the input should be reflected by the algorithm or not.
                    </div>
                    <h5>
                        bool reflect_output = true
                    </h5>
                    <div>
                        If the output should be reflected by the algorithm or not.
                    </div>
                    <h5>
                        unsigned int starting_value = 0xffffffff
                    </h5>
                    <div>
                        Starting value of the CRC algorithm calculation, by default to a binary full of "1", or an hexadecimal full of "f".
                    </div>
                    <h5>
                        unsigned int xor_final = 0xffffffff
                    </h5>
                    <div>
                        Value which the is apply by XOR to the final CRC, by default to a binary full of "1", or an hexadecimal full of "f".
                    </div>
                </div>
            </div>
            <h3>
                Binary manipulation
            </h3>
            <div>
                Even if the Bytes_Set class exists, there are some binary manipulation functions.
                They do the same things that in the Bytes_Set class, but in a less optimized way (even if they are used in the class).
                Excluding if you have no choice, it is recommended to use the Bytes_Set class instead of this functions.</br>
                The only thing added only by this part is the reflection feature, allowing to reflect bits into a char, an int, an unsigned char or an unsigned int.
                <h4>
                    Functions
                </h4>
                <div>
                    <h5>
                        short extract_2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract a short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned short extract_u2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an unsigned short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int extract_4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        unsigned int extract_u4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an unsigned int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        int64_t extract_8bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract an int64_t from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        double extract_double_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Extract a double from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_2bytes_to_char_array(short n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_2bytes_to_char_array(unsigned short n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the unsigned short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_4bytes_to_char_array(int n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_4bytes_to_char_array(unsigned int n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the unsigned int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_8bytes_to_char_array(int64_t n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the int64_t "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        void put_8bytes_double_to_char_array(double n, char* result, unsigned int offset = 0, bool big_endian = false)
                    </h5>
                    <div>
                        Put the double "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".
                    </div>
                    <h5>
                        char reflect_char(char x)
                    </h5>
                    <div>
                        Reflect the char "x" and return it.
                    </div>
                    <h5>
                        unsigned char reflect_char(unsigned char x)
                    </h5>
                    <div>
                        Reflect the unsigned char "x" and return it.
                    </div>
                    <h5>
                        int reflect_int(int x)
                    </h5>
                    <div>
                        Reflect the int "x" and return it.
                    </div>
                    <h5>
                        int reflect_int(unsigned int x)
                    </h5>
                    <div>
                        Reflect the unsigned int "x" and return it.
                    </div>
                </div>
            </div>
            <h3>
                Binary file manipulation
            </h3>
            <div>
                Even if the Bytes_Set class exists, there are some binary file manipulation functions.
                They do the same things that in the Bytes_Set class, but in a less optimized way (even if they are used in the class).
                Excluding if you have no choice, it is recommended to use the Bytes_Set class instead of this functions.
                <h4>
                    Functions
                </h4>
                <div>
                    <h5>
                        void read_file_binary(std::string path, char* datas, unsigned int size, unsigned int start_pos = 0)
                    </h5>
                    <div>
                        Put "size" bytes of the file at the path "path" into the char array "datas", starting at the pos "start_pos" in the file.
                    </div>
                    <h5>
                        char* read_entire_file_binary(std::string path, unsigned int& total_size)
                    </h5>
                    <div>
                        Put the entire content of the file at the path "path" into the char array returned, and put into the referenced variable "total_size" the size of the datas.
                    </div>
                    <h5>
                        void write_in_file_binary(std::string path, char* to_write, unsigned int size, std::ios::openmode opening_mode = std::ios::out | std::ios::binary)
                    </h5>
                    <div>
                        Write "size" bytes of the char array "to_write", in the file at the path "path", opened with the mode defined by "opening_mode".
                    </div>
                </div>
            </div>
            <h3>
                Code specification
            </h3>
            <div>
                This file define the macro "SCLS_FOUNDATION_BINARY".
            </div>
        </div>
    </body>
</html>