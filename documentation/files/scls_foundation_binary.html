<!DOCTYPE html>
<html lang="fr">
    <head>
        <link rel="stylesheet" href="../style.css">
        <meta charset="utf-8">
        <title>SCLS Foundamental "Leonhard" - Binary</title>
    </head>
    <body>
        <h1>SCLS Foundamental Binary</h1>
        <h2>Presentation</h2>
        <section>
            SCLS Foundamental Binary allows the user to do some simple, but secure binary manipulation.&lt;/br&gt;&lt;/br&gt;
            WARNING : Using binary can cause troubles if you don't know what you do. Be very careful with that.
        </section>
        <h2>
            The "Bytes_Set" class
        </h2>
        <section>
        <article>
            The main thing about this part of SCLS Foundamental is the "Bytes_Set" class. It represents a class allowing to do some binary manipulation very easily.&lt;/br&gt;
            To be simple, it is a char array enhanced in all points.
            It can manipulate bytes, convert others types to bytes, extract bytes datas to other types datas, do binary file manipulation...
            It provides a protection against buffer overflow error (if you use it correctly) and against data loss.
            It is used in a lot of features in SCLS, and even in others Aster System codes.&lt;/br&gt;
            Some types, like double, need a conversion to another type, with EXACTLY the same bit pattern, but without the same value according to their type.
            For double, it is converted to an int64_t to be stored, and reconverted to be used.
        </article>
        <h3>
            Bytes_Set methods
        </h3>
        <article>
            The methods are documented in alphabetical order, which may not be their place in the code.&lt;/br&gt;
            Excepting the constructors, which is at the start, and the destructor, at the end.
            <h4>
                Bytes_Set()
            </h4>
            <div>
                Most simple Bytes_Set constructor, which does not allocate datas in the memory.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                Bytes_Set(unsigned int new_datas_size)
            </h4>
            <div>
                Advanced Bytes_Set constructor, creating the datas empty of the object of size "new_datas_size".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                Bytes_Set(char* new_datas, unsigned int new_datas_size)
            </h4>
            <div>
                Advanced Bytes_Set constructor, putting the datas of the object to "new_datas" and the size of the datas to "new_datas_size".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                Bytes_Set(const Bytes_Set&amp; byte_set)
            </h4>
            <div>
                Bytes_Set copy constructor, putting the datas of the object to copied "byte_set" datas, same for the size of the datas.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_data(char data)
            </h4>
            <div>
                Add "data" at the end of the datas in the object.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_datas(char* datas_to_add, unsigned int datas_to_add_size)
            </h4>
            <div>
                Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_datas(const char* datas_to_add, unsigned int datas_to_add_size)
            </h4>
            <div>
                Add copied "datas_to_add" of size "datas_to_add_size" at the end of the datas in the object.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_double(double data, bool big_endian = false)
            </h4>
            <div>
                Add the double "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_float(float data, bool big_endian = false)
            </h4>
            <div>
                Add the float "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.&lt;/br&gt;
                WARNING : for now, this function only convert the float to a double and use "add_double". So, it can occurs to unexpected behaviors in some cases.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_int(int data, bool big_endian = false)
            </h4>
            <div>
                Add the int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_int64(int64_t data, bool big_endian = false)
            </h4>
            <div>
                Add the int64_t "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_short(short data, bool big_endian = false)
            </h4>
            <div>
                Add the short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_string(std::string data)
            </h4>
            <div>
                Add the std::string "data" at the end of the datas in the object, by default encoded in UTF-8 (if you well configured your encoder).<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_uint(unsigned int data, bool big_endian = false)
            </h4>
            <div>
                Add the unsigned int "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void add_ushort(unsigned short data, bool big_endian = false)
            </h4>
            <div>
                Add the unsigned short "data" at the end of the datas in the object, in big-endian or not depending to "big_endian" value.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char* datas() const
            </h4>
            <div>
                Return the datas into the object.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int datas_size() const
            </h4>
            <div>
                Return the size of the datas into the object.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char data_at(unsigned int position)
            </h4>
            <div>
                Return the data at the position "position" in the datas.&lt;/br&gt;
                If the position is not in the datas field, the SCLS print function is used to tell it to the user, and the function return 0.&lt;/br&gt;
                It is HIGLY RECOMMENDED to use this function to access datas without the "extract" functions, because it can avoid buffer overflow.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char extract_data(unsigned int offset = 0)
            </h4>
            <div>
                Extract and return a byte, with a position offset of "offset".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char* extract_datas(unsigned int extract_size, unsigned int offset = 0, bool inverse = false)
            </h4>
            <div>
                Extract and return a "extract_size" sized amount of data, with a position offset of "offset", inversed or not depending to "inverse".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                double extract_double(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return a double, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                float extract_float(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return a float, with a position offset of "offset", in big_endian or not depending to "big_endian".&lt;/br&gt;
                WARNING : for now, this function only convert the float to a double and use "extract_double". So, it can occurs to unexpected behaviors in some cases.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int extract_int(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return an int, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int extract_int64(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return an int64_t, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                short extract_short(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return a short, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                std::string extract_string(unsigned int extract_size, unsigned int offset = 0)
            </h4>
            <div>
                Extract and return a std::string of size "extract_size", with a position offset of "offset".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int extract_uint(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return an unsigned int, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned short extract_ushort(unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract and return an unsigned short, with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void free_memory()
            </h4>
            <div>
                Free the memory of the datas, and reset the datas.&lt;/br&gt;
                If the datas are a "0" pointer, then the memory is freed.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                bool load_from_file(std::string path)
            </h4>
            <div>
                Load the datas of the object from a file at the path "path" and return file is all is good.&lt;/br&gt;
                If the path does not exist, the object is not loaded and "false" is returned.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void save(std::string path)
            </h4>
            <div>
                Save the datas of the object in a file at the path "path".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void set_data_at(unsigned int position, char new_data)
            </h4>
            <div>
                Set the data at the position "position" at "new_data".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                ~Bytes_Set()
            </h4>
            <div>
                Bytes_Set class destructor, calling the "free_memory" function.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        </section>
        <h2>
        CRC manipulation
        </h2>
        <section>
        <article>
            This file contains a way to handle simple CRC manipulation.
            CRC is an algorithm allowing to check datas, to know if their transmission was successfull or not.&lt;/br&gt;
            The only sized algorithm handled is 32 bits for now. Each algorithm has a name, made to easily use them.&lt;/br&gt;
            If you want more information about CRC, see <a href="https://github.com/gentooinit/crc/blob/master/crc.txt">A PAINLESS GUIDE TO CRC ERROR DETECTION ALGORITHMS</a>.
        </article>
        <h3>
            Built-in algorithms
        </h3>
        <article>
            <h4>
                PNG CRC algorithm
            </h4>
            <div>
                The file has a built-in CRC, called "png", made to use the CRC algorithm of the PNG format.
            </div>
        </article>
        <h3>
            Functions
        </h3>
        <article>
            <h4>
                bool contains_crc_32b(std::string name)
            </h4>
            <div>
                Returns if the CRC 32 bits algorithm "name" is loaded or not.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int crc_32b(char* buf, int len, std::string crc_name)
            </h4>
            <div>
                Return the CRC value of the char* "buf" of size "len", with the datas of the loaded CRC_32B_Datas named "name".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int crc_32b(unsigned char* buf, int len, std::string crc_name)
            </h4>
            <div>
                Return the CRC value of the unsigned char* "buf" of size "len", with the datas of the loaded CRC_32B_Datas named "name".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                CRC_32B_Datas* get_crc_32b_data(std::string name)
            </h4>
            <div>
                Returns a pointer to the CRC_32B_Datas named "name".&lt;/br&gt;
                If is does not exists, it returns 0 or it creates it if the name is built-in.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void make_crc_32b_table(std::string name, unsigned int polymonial, bool reflect_input, bool reflect_output, unsigned int starting_value, unsigned int xor_final)
            </h4>
            <div>
                Create a CRC 32 bits algorithm with the passed values.&lt;/br&gt;
                Each values directly goes into the same named CRC_32B_Datas attribute.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        <h3>
            Hidden things
        </h3>
        <article>
            <h4>
                std::map&lt;std::string, CRC_32B_Datas&gt; _loaded_crc32_algorithms
            </h4>
            <div>
                This variable stores the loaded CRC 32 bits algorithms.&lt;/br&gt;
                It's not recommended to use it directly. Use "get_crc_32b_data" instead.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        <h3>
            Macros
        </h3>
        <article>
            <h4>
                #define PNG_CRC_POLYMONIAL 0x04c11db7
            </h4>
            <div>
                Polymonial of the PNG CRC algorithm.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        <h3>
            Struct CRC_32B_Datas
        </h3> 
        <article>
            By default, all the values permit to load the CRC datas of the PNG CRC algorithm.
            <h4>
                unsigned int crc_values[256]
            </h4>
            <div>
                All 256 CRC values possible for this algorithm.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int polymonial
            </h4>
            <div>
                Value of the polymonial of the CRC, by default to PNG_CRC_POLYMONIAL.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                bool reflect_input = true
            </h4>
            <div>
                If the input should be reflected by the algorithm or not.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                bool reflect_output = true
            </h4>
            <div>
                If the output should be reflected by the algorithm or not.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int starting_value = 0xffffffff
            </h4>
            <div>
                Starting value of the CRC algorithm calculation, by default to a binary full of "1", or an hexadecimal full of "f".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int xor_final = 0xffffffff
            </h4>
            <div>
                Value which the is apply by XOR to the final CRC, by default to a binary full of "1", or an hexadecimal full of "f".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        </section>
        <h2>
        Binary manipulation
        </h2>
        <section>
        <article>
            Even if the Bytes_Set class exists, there are some binary manipulation functions.
            They do the same things that in the Bytes_Set class, but in a less optimized way (even if they are used in the class).
            Excluding if you have no choice, it is recommended to use the Bytes_Set class instead of this functions.&lt;/br&gt;
            The only thing added only by this part is the reflection feature, allowing to reflect bits into a char, an int, an unsigned char or an unsigned int.
        </article>
        <h3>
            Functions
        </h3>
        <article>
            <h4>
                short extract_2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract a short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned short extract_u2bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract an unsigned short from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int extract_4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract an int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned int extract_u4bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract an unsigned int from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int64_t extract_8bytes_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract an int64_t from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                double extract_double_from_char_array(char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Extract a double from the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_2bytes_to_char_array(short n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_2bytes_to_char_array(unsigned short n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the unsigned short "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_4bytes_to_char_array(int n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_4bytes_to_char_array(unsigned int n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the unsigned int "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_8bytes_to_char_array(int64_t n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the int64_t "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void put_8bytes_double_to_char_array(double n, char* result, unsigned int offset = 0, bool big_endian = false)
            </h4>
            <div>
                Put the double "n" in the char array "result", with a position offset of "offset", in big_endian or not depending to "big_endian".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char reflect_char(char x)
            </h4>
            <div>
                Reflect the char "x" and return it.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                unsigned char reflect_char(unsigned char x)
            </h4>
            <div>
                Reflect the unsigned char "x" and return it.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int reflect_int(int x)
            </h4>
            <div>
                Reflect the int "x" and return it.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                int reflect_int(unsigned int x)
            </h4>
            <div>
                Reflect the unsigned int "x" and return it.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        </section>
        <h2>
        Binary file manipulation
        </h2>
        <section>
        <article>
            Even if the Bytes_Set class exists, there are some binary file manipulation functions.
            They do the same things that in the Bytes_Set class, but in a less optimized way (even if they are used in the class).
            Excluding if you have no choice, it is recommended to use the Bytes_Set class instead of this functions.
        </article>
        <h3>
            Functions
        </h3>
        <article>
            <h4>
                void read_file_binary(std::string path, char* datas, unsigned int size, unsigned int start_pos = 0)
            </h4>
            <div>
                Put "size" bytes of the file at the path "path" into the char array "datas", starting at the pos "start_pos" in the file.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                char* read_entire_file_binary(std::string path, unsigned int&amp; total_size)
            </h4>
            <div>
                Put the entire content of the file at the path "path" into the char array returned, and put into the referenced variable "total_size" the size of the datas.<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
            <h4>
                void write_in_file_binary(std::string path, char* to_write, unsigned int size, std::ios::openmode opening_mode = std::ios::out | std::ios::binary)
            </h4>
            <div>
                Write "size" bytes of the char array "to_write", in the file at the path "path", opened with the mode defined by "opening_mode".<br />
                This function was added in the version 0.1 and last edited in the version 0.1.
            </div>
        </article>
        </section>
        <h2>
        Code specification
        </h2>
        <section>
        This file define the macro "SCLS_FOUNDATION_BINARY".
        </section>
    </body>
</html>